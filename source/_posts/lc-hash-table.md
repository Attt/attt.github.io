---
title: Hash Table 散列表
date: 2022-08-01 20:20:14
tags:
    - data structures
    - leetcode
    - algorithm
categories:
    - 伸展运动
    - 数据结构
---
## [Hash Table](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)

### Hash函数
#### 直接定址
- hash(k) = k，用key
- hash(k) = ak + b，key相关的`线性函数`

适用key集中的情况，如果key分散的话空间浪费会比较严重。

#### 数字分析
找出key的规律，利用规律降低冲突（和直接定址的线性函数有一点重叠，但是数字分析重点是规律，也就不局限于‘线性’），比如用身份证的月日加上后四位。

#### 平方取中
[平方取中](https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95)是一种‘伪随机数算法’，可以得到特定长度内的伪随机数。

#### 折叠
按位数分割，然后各部分叠加，舍去进位。

#### 随机数
[平方取中](#平方取中)算是其中一种。

#### 取余
最大长度m，选取一个数p不大于m，

hash(k) = k mod p, p < m

### 冲突解决方案
#### 开放定址
hash_i = (hash(k) + d_i) mod m, 其中m是最大长度，i是定址次数，d_i是第i次的序列：

- 线性探测，d=1,2,3...
- 平方探测，d=1^2,2^2,3^2...
- 伪随机探测，d=ran(k)

开放定址的hash函数要求比较高，需要非常均匀，否则一旦出现聚集插入数据时就会增加定址次数

#### 单独链表
在冲突的位置放置链表

#### 双散列
hash两次

#### 再散列
准备一堆hash函数，然后冲突了就套娃：

k_i = hash_i-1(....(k))

#### 公共溢出区
比如准备一个链表，和单独链表有点像，只不过这里的链表是放在“公共”区的，冲突的元素都放在一个链表里，当然用别的数据结构也可以。

### Load factor 载荷因子
元素个数/表长度，由于即使hash足够均匀，最终的元素必须放置在小于表长度的位置中，留给余下的元素的位置越少，产生冲突的概率越大：

假设有一个长度为m、载荷因子为a的表，且hash函数相对均匀，

那么不难得出，在写入第n个元素时冲突的概率p为`n-1/m，n <= a*m`,

若取a的极限值0，也就是不会有元素写入，可以看作冲突概率p恒为0。

换成朴素的证明：
```text
当a = 0.8
    n=1，m=10时，p=0/10
    n=2，m=10时，p=1/10
    ...
    n=8，m=10时，p=7/10
    n=9，因为此时9 > 0.8 * 10，不满足n <= a*m，需要对表扩容或者不再写入，因此a=0.8时最大的冲突概率为7/10
再
当a = 0.6
    n=1，m=10时，p=0/10
    ...
    n=6，m=10时，p=1/2
    n=7，此时原因同上，a=0.6时最大的冲突概率为1/2
当a = 0.5，最大p=2/5
...
```
因此，在相同的hash函数下，理论上载荷因子越小，冲突的概率越小，但是载荷因子过于小会造成空间的浪费。

### 性能因素
1. hash的均匀程度（冲突概率，冲突必然增加开销）
2. 冲突解决方案
    1. 比如单链增加空间开销和时间开销、开放定址增加时间开销、再散列增加时间开销等
    2. 各种冲突方案的开销并不是定量的，比如单链增加的时间开销和开放定址增加的时间开销并不相当，需要考虑开放定址的hash函数算法的时间复杂度与链表查询的时间复杂度，且即使开放定址的hash函数时间复杂度为O(n)，其n的常数系数也大概率与链表的不同
3. 载荷因子（冲突概率）

### Java实现
数据结构部分：
```java
/**
 * 散列表
 * 冲突策略：单链
 */
class HashTable{
    Node[] hashSlots;
    // 散列槽数量
    int slotsSize;
    // 当前元素数量
    int elementCount;
    // load factor
    float loadFactor = 0.6f;
}

/**
 * 节点
 */
class Node{
    Object key;
    Object object;
    // 下一个节点
    Node next;
}
```