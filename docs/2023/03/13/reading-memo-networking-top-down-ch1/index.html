

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/me.png">
  <link rel="icon" href="/images/me.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154de">
  <meta name="author" content="attt">
  <meta name="keywords" content="">
  
    <meta name="description" content="好记性不如流水账  Principles of Network Applications应用层的程序编写不需要过多考虑网络的核心设备的运行，这是网络中各种各样应用发展快的原因。 Network Application Architectures应用层程序架构  client-server（中心化） peer-to-peer（无中心化）  client-server架构中，通常client互相不会">
<meta property="og:type" content="article">
<meta property="og:title" content="Computer Networking - Application Layer">
<meta property="og:url" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/index.html">
<meta property="og:site_name" content="Attt&#39;s ブログ">
<meta property="og:description" content="好记性不如流水账  Principles of Network Applications应用层的程序编写不需要过多考虑网络的核心设备的运行，这是网络中各种各样应用发展快的原因。 Network Application Architectures应用层程序架构  client-server（中心化） peer-to-peer（无中心化）  client-server架构中，通常client互相不会">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-14%2021.10.56.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-14%2021.51.57.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-14%2022.06.50.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2010.57.16.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2014.01.32.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2014.22.39.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2014.25.06.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2014.35.29.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2020.37.43.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2020.38.01.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2021.37.10.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2021.40.53.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2014.23.27.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2014.27.20.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2015.00.39.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2015.16.17.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2020.41.47.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2021.46.11.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2022.17.56.png">
<meta property="og:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2022.29.19.png">
<meta property="article:published_time" content="2023-03-13T15:21:31.000Z">
<meta property="article:modified_time" content="2023-03-16T15:08:38.256Z">
<meta property="article:author" content="attt">
<meta property="article:tag" content="networking">
<meta property="article:tag" content="http">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://attt.github.io/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-14%2021.10.56.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Computer Networking - Application Layer - Attt&#39;s ブログ</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fonts.css">
<link rel="stylesheet" href="/css/fix-input-shadow.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"attt.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":10,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 40vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Attt&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首 页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归 档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分 类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标 签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关 于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/images/eye.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Computer Networking - Application Layer"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        attt
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-13 23:21" pubdate>
          2023年3月13日 星期一 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          150 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Computer Networking - Application Layer</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>好记性不如流水账</p>
</blockquote>
<h2 id="Principles-of-Network-Applications"><a href="#Principles-of-Network-Applications" class="headerlink" title="Principles of Network Applications"></a>Principles of Network Applications</h2><p>应用层的程序编写不需要过多考虑网络的核心设备的运行，这是网络中各种各样应用发展快的原因。<br><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-14%2021.10.56.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="Network-Application-Architectures"><a href="#Network-Application-Architectures" class="headerlink" title="Network Application Architectures"></a>Network Application Architectures</h3><p>应用层程序架构</p>
<ul>
<li>client-server（中心化）</li>
<li>peer-to-peer（无中心化）</li>
</ul>
<p>client-server架构中，通常client互相不会通信，server处于持续运行状态且拥有固定的地址（域名、IP），因此所有的client都可以轻松访问获取内容，同时为了防止单个server出现单点故障，通常会在多个data center部署多个server。</p>
<p>P2P架构中，几乎不依赖data center中的server，不同的hosts间相互通信，称为peer。P2P架构的优势是成本低（不用专用的server）、self-scalability（自我扩展），与之相对的可靠性、安全性、性能也是其缺点。</p>
<h3 id="Processes-Communicating"><a href="#Processes-Communicating" class="headerlink" title="Processes Communicating"></a>Processes Communicating</h3><p>网络中讨论的process间的通讯指不同end system上的processes之间的通讯。<em>（这里可以复习一下本地processess间的通讯途径和实现）</em></p>
<p><strong>Client and Server Processes</strong></p>
<p>如何定义client process和server process：</p>
<blockquote>
<p>In the context of a communication session between a pair of processes, the pro- cess that initiates the communication (that is, initially contacts the other process at the beginning of the session) is labeled as the client. The process that waits to be contacted to begin the session is the server.</p>
</blockquote>
<p>为了简化模型client和server的分别只是看哪一方先发起communication session，因此在P2P架构中也有client和server，只不过peer可以扮演两种角色。（要区别“full-duplex”和“half-duplex”，全双工&#x2F;半双工的概念指的是能否同时进行上下行通信，而client process和server process讨论的是角色）</p>
<p><strong>The Interface Between the Process and the Computer Network</strong></p>
<p>process通过叫做“socket”的software interface发出消息到网络（对于process来说消息给到socket之后确实就属于“网络”了，因为process并不用关心细节），也通过socket来接受消息。（这东西翻译成“套接字”是真的…)</p>
<p>socket是software层面的定义，实际作用是给了个入口和出口，将消息转移到下一层（通常是transport-layer）。通常transport-layer的细节实现都由OS来负责。</p>
<p>可以这么理解：socket是OS获取打包好的application-layer消息并且进一步打包成transport-layer消息（传出）、拆解transport-layer消息取出并送达application-layer消息（传入）的API。（在transport-layer这方面，应用程序顶多只能做选择。选择比努力更…）</p>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-14%2021.51.57.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>Addressing Processes</strong></p>
<p>IP address确定目标host，port number确定目标host上的目标process。</p>
<h3 id="Transport-Services-Available-to-Applications"><a href="#Transport-Services-Available-to-Applications" class="headerlink" title="Transport Services Available to Applications"></a>Transport Services Available to Applications</h3><p>transport-layer提供的服务分为四个方面：可靠数据传输、吞吐量、即时性、安全性。</p>
<p><strong>Reliable Data Transfer</strong></p>
<p>具体问题具体分析，比如音视频流可能不太需要过于可靠（有点数据丢失或者错误问题不大），文件传输或者邮件之类的可能就必须保证可靠性。</p>
<p>押镖就不能把货弄丢喽，传情书就无所谓了，反正是缘分。</p>
<p><strong>Throughput</strong></p>
<p>对速率bitrate有保障，比如指定码率的直播推流，就需要有一定的速率保障。</p>
<p><strong>Timing</strong></p>
<p>即时性，即时通讯、在线游戏之类的都需要保障一定的即时性，但邮件这种肯定不需要。</p>
<p>其实邮件也可以要，但 没必要。</p>
<p><strong>Security</strong></p>
<p>不只是加密，还包括了完整性验证和身份验证。</p>
<p>总之突出一个安全放心。</p>
<h3 id="Transport-Services-Provided-by-the-Internet"><a href="#Transport-Services-Provided-by-the-Internet" class="headerlink" title="Transport Services Provided by the Internet"></a>Transport Services Provided by the Internet</h3><p>互联网提供了TCP和UDP两种协议（TM不是只有这两种！是互联网the Internet提供了这两种）。</p>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-14%2022.06.50.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>TCP Services</strong></p>
<p>TCP协议提供的服务：</p>
<ul>
<li>Connection-oriented service</li>
<li>Reliable data transfer service</li>
</ul>
<p>connection这个概念其实是个抽象的东西，不是说建立了connection就是千里姻缘一线牵了，不是真的有个什么东西连上了。</p>
<p>那为啥要这个抽象的概念呢，就是为了搞事情，搞拆分、搞flow control、搞congestion control、再搞搞retransmission什么的。要让分别在两个host上的两个process之间完成基本交流通过四元组（src IP + src port + dest IP + dest port）就够了，但是如果要搞事情，就还需要记一些东西，比如接收方记录一下现在哪些segment已经送到了，发送方当然也要记录，就要有buffer来放这些记录，来记状态。</p>
<p>所以总有个时机来创建这些个buffer，所以约定一个牵手流程（建立connection)，手一牵上那大家就准备准备要开始做笔记了。</p>
<p>分手这笔记就可以撕了。</p>
<p>congestion-control mechanism，拥堵控制是用来保证整个网络的可用性和公平性。（TCP协议的研究大部分是在这个上面做文章）</p>
<p>安全性方面TLS</p>
<p><strong>UDP Services</strong></p>
<p>无connection，最基础的传输层协议，除了把消息发出去，基本上只有校验数据包完整性的功能。</p>
<p><strong>Services Not Provided by Internet Transport Protocols</strong></p>
<blockquote>
<p>today’s Internet can often provide satisfactory service to time-sensitive applications, but it cannot provide any timing or throughput guarantees.</p>
</blockquote>
<p>互联网不提供即时性和吞吐的保障。由于网络的复杂性，每次消息都会经过多个节点多个ISP无数条线路，基于成本很难保证这两个特性。不过应用程序（end system）可以曲线救国，通过增加线路、冗余发送、压缩等手段提高即时性和吞吐。</p>
<h3 id="Application-Layer-Protocols"><a href="#Application-Layer-Protocols" class="headerlink" title="Application-Layer Protocols"></a>Application-Layer Protocols</h3><p>一个application-layer protocol定义了：</p>
<ul>
<li>消息类型，请求和响应</li>
<li>如何区分消息类型</li>
<li>消息中各个部分的含义</li>
<li>process如何处理（接收、发送、解释）消息</li>
</ul>
<p>HTTP是RFC(Request for Comments)定义的公开协议。（当然也可以定义私有协议）</p>
<h2 id="The-Web-and-HTTP"><a href="#The-Web-and-HTTP" class="headerlink" title="The Web and HTTP"></a>The Web and HTTP</h2><h3 id="Overview-of-HTTP"><a href="#Overview-of-HTTP" class="headerlink" title="Overview of HTTP"></a>Overview of HTTP</h3><p>基于<strong>TCP</strong>协议的<strong>无状态</strong>的<em>HyperText Transfer Protocol</em>，可靠完整由TCP来保证。（HTTP&#x2F;3基于UDP，因此一些TCP保证的特性需要在上一层也就是application-layer的HTTP&#x2F;3中实现）</p>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2010.57.16.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="Non-Persistent-and-Persistent-Connections"><a href="#Non-Persistent-and-Persistent-Connections" class="headerlink" title="Non-Persistent and Persistent Connections"></a>Non-Persistent and Persistent Connections</h3><p><strong>HTTP with Non-Persistent Connections</strong></p>
<p>初代HTTP，每个请求都发起一次新的TCP连接，简约而不简单。</p>
<p><strong>HTTP with Persistent Connections</strong></p>
<p>HTTP&#x2F;1.1开始，多个请求复用TCP连接，也给大家伙儿带来了HOL问题。</p>
<h3 id="HTTP-Message-Format"><a href="#HTTP-Message-Format" class="headerlink" title="HTTP Message Format"></a>HTTP Message Format</h3><p>RFC：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc1945">Hypertext Transfer Protocol – HTTP&#x2F;1.0</a></li>
<li><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc7230">Hypertext Transfer Protocol (HTTP&#x2F;1.1): Message Syntax and Routing</a></li>
<li><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP&#x2F;2)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc9113">HTTP&#x2F;2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc9114">HTTP&#x2F;3</a></li>
</ul>
<p><strong>HTTP Request Message</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GET</span> /somedir/page.html HTTP/<span class="hljs-number">1.1</span> <br>Host: www.someschool.edu <br><span class="hljs-keyword">Connection</span>: <span class="hljs-keyword">close</span><br><span class="hljs-keyword">User</span>-agent: Mozilla/<span class="hljs-number">5.0</span> <br>Accept-<span class="hljs-keyword">language</span>: fr<br></code></pre></td></tr></table></figure>
<ol>
<li>HTTP消息是由ASCII文字编写</li>
<li>第一行是request line(请求行)：格式是 [method] [url] [protocol&#x2F;version], 接下来的都是header line(头行?)</li>
<li>Host指明了目标host的位置（这是application-layer的事情，TCP虽然已经连上了，但是由于HTTP是无状态的，不同的TCP连接可能处理完全相同的HTTP请求，那如果要做web缓存，肯定是基于这个host比较好。而且web缓存也是application-layer）</li>
<li>Connection，close表示请求完成之后关闭连接，具体定义参照RFC：</li>
</ol>
<blockquote>
<p>  o  If the “close” connection option is present, the connection will<br>     not persist after the current response; else,</p>
<p>  o  If the received protocol is HTTP&#x2F;1.1 (or later), the connection<br>     will persist after the current response; else,</p>
<p>  o  If the received protocol is HTTP&#x2F;1.0, the “keep-alive” connection<br>     option is present, the recipient is not a proxy, and the recipient<br>     wishes to honor the HTTP&#x2F;1.0 “keep-alive” mechanism, the<br>     connection will persist after the current response; otherwise,</p>
<p>  o  The connection will close after the current response.</p>
</blockquote>
<ol>
<li>User-agent用户代理，提供当前client的信息</li>
<li>Accept-language表示client能够接受的内容语言</li>
</ol>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2014.01.32.png" srcset="/img/loading.gif" lazyload></p>
<ol start="7">
<li>entity body是POST用的，GET方法参数是通过URL携带</li>
<li>最开始的RFC里URL没有规定长度，但是某些浏览器限制2000chars，且CDN也会限制URL的长度，最好短点，有话放在body说。</li>
</ol>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2014.22.39.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2014.25.06.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>HTTP Response Message</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br>Connection: <span class="hljs-built_in">close</span><br>Date: Tue, <span class="hljs-number">18</span> Aug <span class="hljs-number">2015</span> <span class="hljs-number">15</span>:<span class="hljs-number">44</span>:<span class="hljs-number">04</span> GMT<br>Server: Apache/<span class="hljs-number">2.2</span><span class="hljs-number">.3</span> (CentOS)<br>Last-Modified: Tue, <span class="hljs-number">18</span> Aug <span class="hljs-number">2015</span> <span class="hljs-number">15</span>:<span class="hljs-number">11</span>:<span class="hljs-number">03</span> GMT <br>Content-Length: <span class="hljs-number">6821</span><br>Content-Type: text/html<br>(data data data data data ...)<br></code></pre></td></tr></table></figure>

<ol>
<li>第一行是status line(状态行)，格式[protocol&#x2F;version] [status code] + [phrase]，接下来是header line，最后是entity body</li>
<li>Connection和request时意义一样，这里是server告诉client接下来会关闭连接</li>
<li>Date是server发送响应的时间</li>
<li>Server提供server的信息</li>
<li>Last-Modified是资源最后被修改的时间（包括创建），这个对web缓存很重要</li>
<li>Content-Length内容的长度</li>
<li>Content-Type返回响应的资源类型</li>
</ol>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2014.35.29.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="User-Server-Interaction-Cookies"><a href="#User-Server-Interaction-Cookies" class="headerlink" title="User-Server Interaction: Cookies"></a>User-Server Interaction: Cookies</h3><p>RFC:</p>
<p><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc6265">HTTP State Management Mechanism</a></p>
<p>最初设计是想用来标识用户身份，后来用于保存会话状态，本质是提供了一个手段让无状态的HTTP带上那么点状态。</p>
<h3 id="Web-Caching"><a href="#Web-Caching" class="headerlink" title="Web Caching"></a>Web Caching</h3><p>看图说话</p>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2020.37.43.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2020.38.01.png" srcset="/img/loading.gif" lazyload></p>
<p>还是缓存的基本作用，CDN（Content Distribution Networks）也没差。</p>
<p><strong>The Conditional GET</strong></p>
<p>引入缓存后第一个要考虑一致性问题：</p>
<ol>
<li>cache向server请求时server在响应中会带上<code>Last-Modified</code>头信息，表示资源的修改时间，这个时间也会被缓存下来。</li>
<li>如果再次请求这个资源时，cache会发起conditional GET，头信息包含<code>If-Modified-Since</code>，这个时间就是cache中的资源时间，此时<ol>
<li>如果server的资源修改过，会返回新的资源响应，带上最新的Last-Modified，然后cache更新。</li>
<li>如果server的资源在Last-Modified之后没有修改过，则向cache返回只包含status line和header line的响应（304 Not Modified）。</li>
</ol>
</li>
</ol>
<p>会增加一点响应时间和带宽消耗。</p>
<h3 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><blockquote>
<p>The primary goals for HTTP&#x2F;2 are to reduce perceived latency by enabling request and response multiplexing over a single TCP connection, provide request prioritization and server push, and provide efficient compression of HTTP header fields. HTTP&#x2F;2 does not change HTTP methods, status codes, URLs, or header fields. Instead, HTTP&#x2F;2 changes how the data is formatted and transported between the client and server.</p>
</blockquote>
<ol>
<li>在单个TCP连接上实现请求和响应的multiplexing来减少perceived latency（感知延迟）</li>
<li>优先级请求</li>
<li>服务端推送</li>
<li>HTTP头的高效压缩</li>
</ol>
<p>Head of Line (HOL) blocking，头阻塞问题：如果多个不同的请求都经过一个TCP连接发送，但不幸的是发送队列的头部有个大对象（耗时）的请求，那么在队列后面的即使是小对象的请求也不得不等待。</p>
<p><em>这个看似总等待时间没有变化，但是会严重影响用户的感知延迟，假如一个页面上有多个请求，除了一个超级大的视频之外全部都是文字和小图片，这时候哦豁视频的响应先来了，那么在视频请求完成之前页面就是一片白</em></p>
<p>HTTP&#x2F;1.1的浏览器通过多个TCP连接来缓解这个问题（说好的复用TCP呢。），而且由此方案带来另一个问题：由于TCP的公平性是基于连接的，多个TCP连接理论上可以获得更多带宽，从整个网络设计层面来看，来骗来偷袭更多的带宽这好吗这不好。</p>
<p><em>减少TCP连接其实是想节省资源(socket、内存,etc.）的占用</em></p>
<p><strong>HTTP&#x2F;2 Framing</strong></p>
<p>目标是彻底解决HOL问题，将响应数据拆分成frame，头部数据拆成一个frame，剩下的数据拆成一个或多个frames，对这些frame进行二进制编码，这样就可以交错的在一个TCP连接上传输响应。（可能带来的问题就是需要更大的buffer开销，毕竟需要等到某一个响应的所有frames都到达后才能对进行后续处理）</p>
<p><strong>Response Message Prioritization and Server Pushing</strong></p>
<p>优先级基本靠浏览器实现，不同的浏览器有不同的优先级策略。（体验下用chromium内核之前的edge和用了之后的edge是两个东西，edge真好用！所以我用chrome）</p>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2021.37.10.png" srcset="/img/loading.gif" lazyload></p>
<p>server push需要配置实现，目的减少请求量，比如server除了响应本身请求的网页内容还可以push网页上依赖的资源</p>
<p>举个例子，nginx配置</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;<br>    listen <span class="hljs-number">443</span> ssl http2;<br>    server_name  localhost;<br><br>    ssl                      on;<br>    ssl_certificate          <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/certs/</span>example.crt;<br>    ssl_certificate_key      <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/certs/</span>example.key;<br><br>    ssl_session_timeout  <span class="hljs-number">5</span>m;<br><br>    ssl_ciphers HIGH:!aNULL:!MD5;<br>    ssl_protocols SSLv3 TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>    ssl_prefer_server_ciphers   on;<br><br>    location / &#123;<br>      root   <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html;<br>      index  index.html index.htm;<br>      http2_push /style.css; -- 推送style.css<br>      http2_push /example.png; -- 推送example.png<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>请求根目录&#x2F;时，server会push配置的两个资源。</p>
<p><strong>HTTP&#x2F;3</strong></p>
<p>QUIC，基于UDP的HTTP协议，可靠性公平性都是由application-layer来实现。</p>
<h2 id="Electronic-Mail-in-the-Internet"><a href="#Electronic-Mail-in-the-Internet" class="headerlink" title="Electronic Mail in the Internet"></a>Electronic Mail in the Internet</h2><p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-15%2021.40.53.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>Simple Mail Transfer Protocol (SMTP)，基于TCP，远古协议，比HTTP早得多，ASCII编码。</p>
<h3 id="Mail-Message-Formats"><a href="#Mail-Message-Formats" class="headerlink" title="Mail Message Formats"></a>Mail Message Formats</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">From: alice<span class="hljs-symbol">@crepes</span>.fr<br><span class="hljs-keyword">To</span>: bob<span class="hljs-symbol">@hamburger</span>.edu<br>Subject: Searching <span class="hljs-keyword">for</span> the meaning of life.<br></code></pre></td></tr></table></figure>

<h3 id="Mail-Access-Protocols"><a href="#Mail-Access-Protocols" class="headerlink" title="Mail Access Protocols"></a>Mail Access Protocols</h3><p>Internet Mail Access Protocol (IMAP)，用于访问邮件服务器的协议，客户端接入用这个（省啊，HTTP有点肥大），网页上用HTTP。</p>
<h2 id="DNS—The-Internet’s-Directory-Service"><a href="#DNS—The-Internet’s-Directory-Service" class="headerlink" title="DNS—The Internet’s Directory Service"></a>DNS—The Internet’s Directory Service</h2><p>hostname 和 IP Address映射，将hostname转换为IP Address</p>
<h3 id="Services-Provided-by-DNS"><a href="#Services-Provided-by-DNS" class="headerlink" title="Services Provided by DNS"></a>Services Provided by DNS</h3><p>组成部分：</p>
<ul>
<li>分布式数据库</li>
<li>可供host查询该数据库的application-layer protocol，DNS协议</li>
</ul>
<p>举例，访问一个域名的步骤：</p>
<ol>
<li>本地运行DNS的client（这东西OS的）</li>
<li>浏览器访问<a target="_blank" rel="noopener" href="http://www.xxx.com下的资源时,将www.xxx.com传递给dns的client/">www.xxx.com下的资源时，将www.xxx.com传递给DNS的client</a></li>
<li>DNS的client向DNS的server请求<a target="_blank" rel="noopener" href="http://www.xxx.com的ip/">www.xxx.com的IP</a> address</li>
<li>浏览器收到DNS client返回的IP address，通过这个IP建立TCP连接然后发送HTTP请求</li>
</ol>
<p>比用IP直接访问肯定会增加延迟，为了减小延迟DNS服务器实际上不止一台，并且会尽量让所请求的DNS服务器更靠近client。</p>
<p>DNS提供的服务：</p>
<ul>
<li>host别名</li>
<li>邮件服务器别名</li>
<li>负载分布</li>
</ul>
<p>多对多的映射能力，前两个是域名-IP多对一，后面是一对多。</p>
<h3 id="Overview-of-How-DNS-Works"><a href="#Overview-of-How-DNS-Works" class="headerlink" title="Overview of How DNS Works"></a>Overview of How DNS Works</h3><p>基于UDP，默认53端口。</p>
<p><strong>A Distributed, Hierarchical Database</strong></p>
<p>DNS是分布式服务（Distributed），同时是分层服务（Hierarchical）</p>
<p>看图说话<br><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2014.23.27.png" srcset="/img/loading.gif" lazyload></p>
<p>DNS分三类：</p>
<ul>
<li>root DNS servers，根DNS服务器</li>
<li>top-level domain (TLD) DNS servers，顶级域DNS服务器</li>
<li>authoritative DNS servers，授权DNS服务器</li>
</ul>
<p><em><strong>root DNS server</strong></em></p>
<p>全世界1000+的root DNS服务器（2020），提供下一层TLD DNS server的IP地址。<br><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2014.27.20.png" srcset="/img/loading.gif" lazyload></p>
<p><em><strong>TLD DNS server</strong></em></p>
<p>顶级域DNS服务器。com或者国家fr、jp这种级别</p>
<p><em><strong>local DNS server</strong></em></p>
<p>每个ISP（机构&#x2F;住宅）都会有自己的local DNS。</p>
<p>local DNS不在DNS分层结构中，发起DNS请求时先到local DNS：<br><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2015.00.39.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>本地host发起DNS查询请求到local DNS</li>
<li>local DNS查询root DNS</li>
<li>root DNS返回负责的TLD DNS的IP</li>
<li>local DNS查询TLD DNS</li>
<li>TLD DNS返回负责的authoritative DNS的IP</li>
<li>local DNS查询authoritative DNS</li>
<li>authoritative DNS返回请求的host的IP</li>
<li>local DNS将IP地址返回给本地host</li>
</ol>
<p>八次请求！八次！</p>
<p>TLD DNS不是总是有authoritative DNS的地址，还会有中间DNS。</p>
<p>DNS查询的递归+迭代：查询local DNS是递归，因为local DNS还要查别的DNS；local DNS查别的DNS是迭代，平级的。</p>
<p>当然理论上也可以都是递归的，实际一般不这么实现：<br><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2015.16.17.png" srcset="/img/loading.gif" lazyload></p>
<p><em>这种实现有个问题：图中local DNS到root DNS的请求也就是2那个请求，需要等到3456请求都完成了才能返回，root DNS在这种实现模型下负载会更高</em></p>
<p><strong>DNS Caching</strong></p>
<p>顾名思义。</p>
<h3 id="DNS-Records-and-Messages"><a href="#DNS-Records-and-Messages" class="headerlink" title="DNS Records and Messages"></a>DNS Records and Messages</h3><p>resource record(RR)的格式：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">(<span class="hljs-keyword">Name</span>, Value, <span class="hljs-keyword">Type</span>, TTL)<br></code></pre></td></tr></table></figure>

<p>name和value的含义要看type是什么：</p>
<ul>
<li>Type&#x3D;A<ul>
<li>name是hostname</li>
<li>value是IPv4</li>
<li>比如(relay1.bar.foo.com, 145.37.93.126, A)</li>
</ul>
</li>
<li>Type&#x3D;NS<ul>
<li>name是domain</li>
<li>value是负责解析这个domain的dns的hostname</li>
<li>比如(foo.com, dns.foo.com, NS)</li>
</ul>
</li>
<li>Type&#x3D;CNAME<ul>
<li>name是别名hostname（aliased hostname）</li>
<li>value是hostname</li>
<li>比如(foo.com, relay1.bar.foo.com, CNAME)</li>
</ul>
</li>
<li>Type&#x3D;MX（看起来和CNAME一样，但是单独有这个类型的的话，邮件服务器的别名就可以跟CNAME的别名重复了）<ul>
<li>name是别名hostname</li>
<li>value是邮件的hostname</li>
<li>比如(foo.com, mail.bar.foo.com, MX)</li>
</ul>
</li>
</ul>
<p>A记录是存在于authoritative DNS上的，比如aaa.always.fuxk.com，如果dns.fuxk.com不是这个domain的authoritative DNS，那么他会有一条NS记录指向比如说dns.always.fuxk.com，而在dns.always.fuxk.com上面应该就是aaa.always.fuxk.com对应于某个IP的A记录了。（如果是IPv6，那就是AAAA记录，都差不多。）</p>
<p><strong>DNS Messages</strong></p>
<p>看图说话<br><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2020.41.47.png" srcset="/img/loading.gif" lazyload></p>
<p>查询和回复的message格式一致</p>
<ul>
<li>最前面的header section占12 bytes<ul>
<li>identification用来关联查询和回复</li>
<li>flags<ul>
<li>1 bit表示是查询（0）还是回复（1）</li>
<li>1 bit表示回复的消息是authoritative DNS回复的（1）</li>
<li>1 bit表示client要求DNS server在查不到的时候进行递归查询（1）</li>
<li>1 bit表示DNS server是（1）否支持递归查询</li>
</ul>
</li>
<li>4个number表示question section的四种出现次数</li>
</ul>
</li>
<li>question section部分包含查询的name和type，比如aaa.bbb.com, A</li>
<li>answer section部分包含回复的value、type、TTL，可以有多条</li>
<li>authority section是authoritative DNS回复的内容（贵宾待遇。）</li>
<li>additional section包含额外的信息，比如查询MX记录，回复在answer section的是MX对应的hostname记录，那这里就可能是这个hostname对应的IP的A记录。</li>
</ul>
<p><strong>Inserting Records into the DNS Database</strong></p>
<p>注册域名的时候，域名注册商会将这个域名写到DNS，一般的域名注册商也提供authoritative DNS，大多数会有两个一个主要的一个备用的。<br>比如dns1.aaa.com和dns2.aaa.com，然后要配置自己刚注册域名的A记录（至少有个A记录），最后提供这个DNS的服务商会把记录写到TLD DNS里：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">(你的域名<span class="hljs-selector-class">.com</span>, dns1<span class="hljs-selector-class">.aaa</span><span class="hljs-selector-class">.com</span>, NS) <br>(dns1<span class="hljs-selector-class">.aaa</span><span class="hljs-selector-class">.com</span>, <span class="hljs-number">212.212</span>.<span class="hljs-number">212.1</span>, A)<br></code></pre></td></tr></table></figure>

<p>最后来一点小小的震撼：<br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/2014%E5%B9%B4%E4%B8%AD%E5%9B%BD%E5%A4%A7%E9%99%86%E7%BD%91%E7%BB%9C%E5%BC%82%E5%B8%B8%E4%BA%8B%E4%BB%B6">2014年中国大陆网络异常事件</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93">域名服务器缓存污染</a></p>
<p>所以说年轻人还是要学习一个</p>
<h2 id="Peer-to-Peer-File-Distribution"><a href="#Peer-to-Peer-File-Distribution" class="headerlink" title="Peer-to-Peer File Distribution"></a>Peer-to-Peer File Distribution</h2><p>对等网络</p>
<p>熟悉的协议：BT</p>
<p>那可太熟悉了。</p>
<p><strong>Scalability of P2P Architectures</strong></p>
<p>扩展性，不同与server-client模式，P2P随着参与peer的增多不会明显增加分发耗时。</p>
<p><strong>BitTorrent</strong></p>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2021.46.11.png" srcset="/img/loading.gif" lazyload></p>
<p>trade algorithm（tit-for-tat）：</p>
<ul>
<li>参与某个torrent下载分发的peer会向tracker服务器上报自己的存在。新加入的peer会从tracker获取正在分发的peer list，并尝试建立连接。</li>
<li>peer会从连接的peers获取对方的chunk信息，优先下载那些比较稀有的chunk。</li>
<li>某些个peer申请下载chunk的时候，通过这个peer给自己提供chunk的速率来决定，优先选几个速率高的。</li>
<li>每隔一段时间，重新测量一下速率。</li>
<li>同样的隔一段时间，找一个随机的peer，向这个peer传他需要的chunk，假如在这个peer中自己变成了他的前几个最高速率的peer之一，那这个peer也会反向传chunk过来，也就有可能变成这边新的最高速率的peer。等于说是打破了江局。</li>
</ul>
<p>DHT网络</p>
<h2 id="Video-Streaming-and-Content-Distribution-Networks"><a href="#Video-Streaming-and-Content-Distribution-Networks" class="headerlink" title="Video Streaming and Content Distribution Networks"></a>Video Streaming and Content Distribution Networks</h2><h3 id="Internet-Video"><a href="#Internet-Video" class="headerlink" title="Internet Video"></a>Internet Video</h3><h3 id="HTTP-Streaming-and-DASH"><a href="#HTTP-Streaming-and-DASH" class="headerlink" title="HTTP Streaming and DASH"></a>HTTP Streaming and DASH</h3><p>Dynamic Adaptive Streaming over HTTP (DASH)</p>
<p>视频的码率，通过对原始视频进行不同参数的压缩，产生多个码率的视频，根据变化的网络条件分发不同码率的视频保证流畅。</p>
<h3 id="Content-Distribution-Networks"><a href="#Content-Distribution-Networks" class="headerlink" title="Content Distribution Networks"></a>Content Distribution Networks</h3><ol>
<li>人民日益增长的网络请求和server捉急的带宽之间的矛盾</li>
<li>可以增加server或者带宽，得加钱</li>
<li>大部分资源会被重复请求</li>
</ol>
<p>Content Distribution Networks (CDNs)这年头几乎没有不用的。可以看做是一个分布式静态资源的缓存，有效的减轻了server的压力。</p>
<p>两个部署理念：</p>
<ul>
<li>Enter Deep：把CDN部署到ISP内部，离用户越近越好</li>
<li>Bring Home：把CDN部署在ISP外部比如IXP，每个部署点搞一个集群</li>
</ul>
<p>各有好处。第一个有点贵，ISP那得多少个啊，第二个会比第一多些延迟，毕竟远了点。</p>
<p><strong>CDN Operation</strong></p>
<ol>
<li>决定具体某个CDN集群</li>
<li>将请求发送到这个CDN集群的server</li>
</ol>
<p>一种可行的方法：对静态资源的请求通过DNS解析到CDN</p>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2022.17.56.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>Cluster Selection Strategies</strong></p>
<p>集群选择策略：</p>
<ul>
<li>geographically closest，地理优先，就是用地理库找离Local DNS最近的，不过不一定地理最近的就是网络最近，而且Local DNS也可能距离client较远。</li>
<li>real-time measurements，实时测量，有些测量的消息不一定会被响应（ICMP过滤）</li>
</ul>
<h3 id="Case-Studies-Netflix-and-YouTube"><a href="#Case-Studies-Netflix-and-YouTube" class="headerlink" title="Case Studies: Netflix and YouTube"></a>Case Studies: Netflix and YouTube</h3><p>激动人心的案例教学</p>
<p><strong>Netflix</strong></p>
<p><img src="/2023/03/13/reading-memo-networking-top-down-ch1/%E6%88%AA%E5%B1%8F2023-03-16%2022.29.19.png" srcset="/img/loading.gif" lazyload></p>
<p>全用AWS，但CDN是私有搭建的</p>
<ul>
<li>Content ingestion. 把原始内容上传到Amazon cloud</li>
<li>Content processing. 转码，生产不同码率的内容</li>
<li>Uploading versions to its CDN. 上传到CDN</li>
</ul>
<p>关于CDN</p>
<ul>
<li>网飞在200多个IXP点都有自己的机架，几百个ISP也有自己的机架，Enter Deep和Bring Home结合。</li>
<li>不使用pull的缓存方式，而是在非高峰时期上传内容到CDN。没有足够容量的点就上传热点内容。</li>
<li>由于简化了CDN的设计（只有视频），不需要通过DNS的方式转发到CDN。在AWS中的netflix服务会直接让client去CDN的域名请求。</li>
</ul>
<p><strong>YouTube</strong></p>
<ul>
<li>也是用的私人CDN，基本和网飞的部署策略一样。中西药结合疗效好。</li>
<li>区别是使用了pull的缓存方式，访问的内容miss的时候CDN会去server拉取内容。分配CDN的方式是DNS转发，且基于RTT的测量来分配具体的集群，如果负载高可能会调整分配到远一点的集群。</li>
<li>不是用自适应流媒体，而是要用户自己选择不同的分辨率（码率）。（YouTube看起来也像是自适应，但应该是client完成的，实际上可供消费的不同码率视频版本就那几个，不需要自适应的那么多。网飞的那个自适应可是真的分辨率连选都不让选的。）</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%9F%BA%E7%A1%80%E5%A7%BF%E5%8A%BF/" class="category-chain-item">基础姿势</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%9F%BA%E7%A1%80%E5%A7%BF%E5%8A%BF/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="category-chain-item">读书笔记</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/networking/">#networking</a>
      
        <a href="/tags/http/">#http</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/16/reading-memo-networking-top-down-ch2/" title="Computer Networking - Transport Layer">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Computer Networking - Transport Layer</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/02/lc-heap/" title="Heap 堆">
                        <span class="hidden-mobile">Heap 堆</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <i class="iconfont icon-copyright"></i>2022  <a href="https://github.com/Attt" target="_blank" rel="nofollow noopener"><span>Attt</span></a> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
